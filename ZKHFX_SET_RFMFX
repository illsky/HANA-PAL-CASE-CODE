CREATE PROCEDURE sinopec_ypxs.zkhfx_set_rfmfx(
IN SDATE DATE,
IN EDATE DATE,
IN RDATE DATE,--近因参照日期
IN JE_OPTI NVARCHAR(1),--金额选项
IN KJ_OPTI NVARCHAR(1),--口径选项
IN FF_OPTI NVARCHAR(1),--方法选项
IN JYD DOUBLE,
IN JYQZ DOUBLE,
IN PCD DOUBLE,
IN PCQZ DOUBLE,
IN JED DOUBLE,
IN JEQZ DOUBLE,
IN SQLWHERE CLOB,
--out lk string,
OUT TABNAME NVARCHAR(15),
OUT ERROR NVARCHAR(150)
) LANGUAGE SQLSCRIPT 
AS
BEGIN
/*
修改记录：
--20150326 PKLIU创建<RFM分析>；
--20150331 PKLIU<流水号统计去掉distinct>

功能描述：
--从数据源  "Z1FX_XSE4_ICJYMX"IC卡交易明细和"Z1FX_JYMX_HYJYMX"会员交易明细,根据输入参数，输出结果表，
包含字段为：会员卡号，近因，频次，金额，近因得分，频次得分，金额得分，RFM得分
--SQLWHERE:范围限制条件，不包含日期的限制条件
*/
DECLARE SQL_STR1 CLOB;
DECLARE MAX_JY DOUBLE;
DECLARE MIN_JY DOUBLE;
DECLARE MAX_PC DOUBLE;
DECLARE MIN_PC DOUBLE;
DECLARE MAX_JE DOUBLE;
DECLARE MIN_JE DOUBLE;
DECLARE STEP DOUBLE;
DECLARE SD NVARCHAR(10);
DECLARE ED NVARCHAR(10);
DECLARE RD NVARCHAR(10);
DECLARE RDM_TBNAME NVARCHAR(15);
DECLARE HYKH_ARY NVARCHAR(20) ARRAY;
DECLARE JY_ARY DOUBLE ARRAY;
DECLARE PC_ARY DOUBLE ARRAY;
DECLARE JE_ARY DOUBLE ARRAY;
DECLARE I INTEGER;
DECLARE J INTEGER;
--DECLARE MYCOND1 CONDITION FOR SQL_ERROR_CODE 10001;

--sql异常情况捕捉
DECLARE EXIT HANDLER FOR SQLEXCEPTION
 BEGIN
 ERROR := ::SQL_ERROR_MESSAGE || ::SQL_ERROR_CODE;
END;

--创建结果明细表的随机数临时表名
select '#T'||SUBSTRING(RAND(),8,10) into RDM_TBNAME from dummy;
SQL_STR1 := 'CREATE LOCAL TEMPORARY  TABLE '|| :RDM_TBNAME ||' LIKE SINOPEC_YPXS.KHFX_RFM_RFMFX';
EXEC SQL_STR1;

--创建基础数据的临时表
create local temporary table #basedata
("HYKH" NVARCHAR(20),"JY" DOUBLE,"PC" DOUBLE,"JE" DOUBLE);

--创建处理后数据的临时表
create local temporary table #result
("HYKH" NVARCHAR(20),"JY" DOUBLE,"PC" DOUBLE,"JE" DOUBLE);

sd := to_nvarchar(:sdate,'YYYYMMDD');
ed := to_nvarchar(:edate,'YYYYMMDD');
rd := to_nvarchar(:rdate,'YYYYMMDD');

--根据输入参数确定不同的执行语句
if :KJ_OPTI=1 then 
--口径为1  
 if :JE_OPTI=1 then
 --金额为1
  sql_str1 := 'insert into #basedata'||
  ' select (case when A.HYKH is null then B.HYKH when B.HYKH is null then A.HYKH else A.HYKH end) HYKH,'||
  ' (case when A.JY is null then B.JY when B.JY is null then A.JY else A.JY+B.JY end) JY,'||
  ' (case when A.PC is null then B.PC when B.PC is null then A.PC else A.PC+B.PC end) PC,'||
  ' (case when A.JE is null then B.JE when B.JE is null then A.JE else A.JE+B.JE end) JE from'||
  ' (select GZHYKH HYKH,days_between(max(QDATE),'''||:rd||''') JY,count(GZZHLSH) PC,'||
  ' sum(K0CGLSJE0) JE from "_SYS_BIC"."sinopec.zbyy.xsyy.z1-khfx/Z1FX_XSE4_ICJYMX" where '||
  :sqlwhere||' and GZHYKH !='''' and QDATE>='||:sd||' and QDATE<='||:ed||
  ' group by GZHYKH) A full join '||
  ' (select GZHYKH HYKH,days_between(max(QDATE),'''||:rd||''') JY,count(GZZHLSH) PC,'||
  ' sum(KZYSJE) JE from "_SYS_BIC"."sinopec.zbyy.xsyy.z1-khfx/Z1FX_JYMX_HYJYMX" where '||
  :sqlwhere||' and GZHYKH !='''' and QDATE>='||:sd||' and QDATE<='||:ed||
  ' group by GZHYKH) B on A.HYKH=B.HYKH';
  EXEC SQL_STR1;
 else
 --金额为2
  sql_str1 := 'insert into #basedata'||
  ' select (case when A.HYKH is null then B.HYKH when B.HYKH is null then A.HYKH else A.HYKH end) HYKH,'||
  ' (case when A.JY is null then B.JY when B.JY is null then A.JY else A.JY+B.JY end) JY,'||
  ' (case when A.PC is null then B.PC when B.PC is null then A.PC else A.PC+B.PC end) PC,'||
  ' (case when A.JE is null then round(B.JE/B.PC,2) when B.JE is null then round(A.JE/A.PC,2) else round((A.JE+B.JE)/(A.PC+B.PC),2) end) JE from'||
  ' (select GZHYKH HYKH,days_between(max(QDATE),'''||:rd||''') JY,count(GZZHLSH) PC,'||
  ' sum(K0CGLSJE0) JE from "_SYS_BIC"."sinopec.zbyy.xsyy.z1-khfx/Z1FX_XSE4_ICJYMX" where '||
  :sqlwhere||' and GZHYKH !='''' and QDATE>='||:sd||' and QDATE<='||:ed||
  ' group by GZHYKH) A full join '||
  ' (select GZHYKH HYKH,days_between(max(QDATE),'''||:rd||''') JY,count(GZZHLSH) PC,'||
  ' sum(KZYSJE) JE from "_SYS_BIC"."sinopec.zbyy.xsyy.z1-khfx/Z1FX_JYMX_HYJYMX" where '||
  :sqlwhere||' and GZHYKH !='''' and QDATE>='||:sd||' and QDATE<='||:ed||
  ' group by GZHYKH) B on A.HYKH=B.HYKH';
  EXEC SQL_STR1;
 end if;  
elseif :KJ_OPTI=2 then
--口径为2 
 if :JE_OPTI=1 then
 --金额为1
  sql_str1 := 'insert into #basedata'||
  ' select GZHYKH HYKH,days_between(max(QDATE),'''||:rd||''') JY,count(GZZHLSH) PC,'||
  ' sum(K0CGLSJE0) JE from "_SYS_BIC"."sinopec.zbyy.xsyy.z1-khfx/Z1FX_XSE4_ICJYMX" where '||
  :sqlwhere||' and GZHYKH !='''' and QDATE>='||:sd||' and QDATE<='||:ed||
  ' group by GZHYKH';
  EXEC SQL_STR1;
 else
 --金额为2
  sql_str1 := 'insert into #basedata'||
  ' select A.HYKH HYKH,A.JY JY,A.PC PC,round(A.JE/A.PC,2) JE from'||
  ' (select GZHYKH HYKH,days_between(max(QDATE),'''||:rd||''') JY,count(GZZHLSH) PC,'||
  ' sum(K0CGLSJE0) JE from "_SYS_BIC"."sinopec.zbyy.xsyy.z1-khfx/Z1FX_XSE4_ICJYMX" where '||
  :sqlwhere||' and GZHYKH !='''' and QDATE>='||:sd||' and QDATE<='||:ed||
  ' group by GZHYKH) A';
  EXEC SQL_STR1;
 end if;
else
--口径为3
 if :JE_OPTI=1 then
 --金额为1
  sql_str1 := 'insert into #basedata'||
  ' select GZHYKH HYKH,days_between(max(QDATE),'''||:rd||''') JY,count(GZZHLSH) PC,'||
  ' sum(KZYSJE) JE from "_SYS_BIC"."sinopec.zbyy.xsyy.z1-khfx/Z1FX_JYMX_HYJYMX" where '||
  :sqlwhere||' and GZHYKH !='''' and QDATE>='||:sd||' and QDATE<='||:ed||
  ' group by GZHYKH';
  EXEC SQL_STR1;
 else
 --金额为2
  sql_str1 := 'insert into #basedata'||
  ' select A.HYKH HYKH,A.JY JY,A.PC PC,round(A.JE/A.PC,2) JE from'||
  ' (select GZHYKH HYKH,days_between(max(QDATE),'''||:rd||''') JY,count(GZZHLSH) PC,'||
  ' sum(KZYSJE) JE from "_SYS_BIC"."sinopec.zbyy.xsyy.z1-khfx/Z1FX_JYMX_HYJYMX" where '||
  :sqlwhere||' and GZHYKH !='''' and QDATE>='||:sd||' and QDATE<='||:ed||
  ' group by GZHYKH) A';
  EXEC SQL_STR1;
 end if;
end if;

select max(JY),min(JY) into MAX_JY,MIN_JY from #basedata;
select max(PC),min(PC) into MAX_PC,MIN_PC from #basedata;
select max(JE),min(JE) into MAX_JE,MIN_JE from #basedata;

if :FF_OPTI=1 then
--方法为1
 BASEDATA = select * from #basedata;
 HYKH_ARY := ARRAY_AGG(:BASEDATA.HYKH);
 JY_ARY := ARRAY_AGG(:BASEDATA.JY);
 PC_ARY := ARRAY_AGG(:BASEDATA.PC);
 JE_ARY := ARRAY_AGG(:BASEDATA.JE);
 

 STEP := (:MAX_JY-:MIN_JY)/:JYD;
 FOR I IN 1 .. CARDINALITY(:JY_ARY) DO
  FOR J IN 1..:JYD DO
   IF :JY_ARY[:I]<:MIN_JY+:J*:STEP or :J=:JYD THEN
    JY_ARY[:I] := :JYD+1-:J;
    break;
   END IF;
  END FOR;
 END FOR;
 
 STEP := (:MAX_PC-:MIN_PC)/:PCD;
 FOR I IN 1 .. CARDINALITY(:PC_ARY) DO
  FOR J IN 1..:PCD DO
   IF :PC_ARY[:I]<:MIN_PC+:J*:STEP or :J=:PCD THEN
    PC_ARY[:I] := :J;
    break;
   END IF;
  END FOR;
 END FOR;
 
 STEP := (:MAX_JE-:MIN_JE)/:JED;
 FOR I IN 1 .. CARDINALITY(:JE_ARY) DO
  FOR J IN 1..:JED DO
  IF :JE_ARY[:I]<:MIN_JE+:J*:STEP or :J=:JED THEN
   JE_ARY[:I] := :J;
   break;
   END IF;
  END FOR;
 END FOR;
 
 rst = UNNEST(:HYKH_ARY,:JY_ARY,:PC_ARY,:JE_ARY) AS ("HYKH","JY","PC","JE");
 insert into #result select * from :rst;
 sql_str1 := 'INSERT INTO '|| :RDM_TBNAME ||
 ' select A.HYKH HYKH,A.JY JY,A.PC PC,A.JE JE,B.JYDF JYDF,B.PCDF PCDF,B.JEDF JEDF,'||
 ' B.JYDF+B.PCDF+B.JEDF RFMDF from '||
 ' (select * from #basedata) A,'||
 ' (select HYKH,JY*'||:JYQZ||' JYDF,PC*'||:PCQZ||' PCDF,JE*'||:JEQZ||' JEDF from #result) B'||
 ' where A.HYKH=B.HYKH';
else
--方法为2
 sql_str1 := 'INSERT INTO '|| :RDM_TBNAME ||
 ' select A.HYKH HYKH,A.JY JY,A.PC PC,A.JE JE,A.JYBZH JYDF,A.PCBZH PCDF,A.JEBZH JEDF,'||
 ' A.JYBZH*'||:JYQZ||'+A.PCBZH*'||:PCQZ||'+A.JEBZH*'||:JEQZ||' RFMDF from'||
 ' (select HYKH,JY,PC,JE,round(('||:MAX_JY||'-JY)/('||:MAX_JY||'-'||:MIN_JY||'),2) JYBZH,'||
 ' round((PC-'||:MIN_PC||')/('||:MAX_PC||'-'||:MIN_PC||'),2) PCBZH,'||
 ' round((JE-'||:MIN_JE||')/('||:MAX_JE||'-'||:MIN_JE||'),2) JEBZH from #basedata) A';
end if;
--lk:=:sql_str1;
--signal mycond1 set message_text ='lk';

exec sql_str1;
drop table #basedata;
drop table #result;
TABNAME := :RDM_TBNAME;
end;
